                    // Handle dropdown change
    const handleNetworksTBMerged = async (event: SelectChangeEvent<IdType[]>): Promise<void> => {
        let { target: { value } } = event;
        let selectedValues: string[] = [];
        if (typeof value === 'string') {
            selectedValues = value.split(',');
        } else {
            selectedValues = value;
        }

        // Update the state 
        setNetworksTBMerged(selectedValues);
        const newMatchingColsTBMerged = Object.keys(matchingColsTBMerged)
            .filter(key => selectedValues.includes(key))
            .reduce<Record<IdType, string>>((newObj, key) => {
                newObj[key] = matchingColsTBMerged[key];
                return newObj;
            }, {});
        setMatchingColsTBMerged(newMatchingColsTBMerged);

        // Check and load networks if necessary
        for (const v of selectedValues) {
            if (!networkTables.hasOwnProperty(v)) {
                await loadNetworkById(v);
            }
        }
        return
    };
                
                <FormControl fullWidth margin="normal">
                    <InputLabel id="merge-type-label">Type of Merge</InputLabel>
                    <Select
                        labelId="merge-type-label"
                        id="merge-type"
                        value={mergeType}
                        onChange={handleMergeTypeChange}
                        label="Type of Merge"
                    >
                        <MenuItem value={MergeType.union}>Union</MenuItem>
                        <MenuItem value={MergeType.intersection}>Intersection</MenuItem>
                        <MenuItem value={MergeType.difference}>Difference</MenuItem>
                    </Select>
                </FormControl>

                <Typography variant="h6" style={{ margin: '20px 0' }}>
                    Matching columns:
                </Typography>

                <TableContainer component={Paper}>
                    <Table>
                        <TableHead>
                            <TableRow>
                                <TableCell>{currentNetwork.name}</TableCell>
                                {
                                    networksToBeMerged ? (<TableCell>'Network to be Merged' </TableCell>) :
                                        (networksToBeMerged.map(networkId => {
                                            <TableCell>availableNetworks[networkId]?.name ?? 'Error' </TableCell>
                                        }))
                                }
                                <TableCell>{availableNetworks[networksToBeMerged]?.name ?? 'Network to be Merged'}</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            <TableRow>
                                <TableCell key={currentNetwork.ownerUUID}>
                                    <Select
                                        value={matchingColOne}
                                        onChange={handleSetMatchingColOne}
                                    >
                                        {currentNetwork.nodeColumns.map((column) => (
                                            <MenuItem key={column.name} value={column.name}>
                                                {column.name}
                                            </MenuItem>
                                        ))}
                                    </Select>
                                </TableCell>
                                <TableCell key={networksToBeMerged}>
                                    <Select
                                        value={matchingColTwo}
                                        onChange={handleSetMatchingColTwo}
                                    >
                                        {availableNetworks[networksToBeMerged]?.nodeColumns.map((column) => (
                                            <MenuItem key={column.name} value={column.name}>
                                                {column.name}
                                            </MenuItem>
                                        )) ?? ''}
                                    </Select>
                                </TableCell>
                            </TableRow>
                        </TableBody>
                    </Table>
                </TableContainer>

                <Typography variant="h6" style={{ margin: '20px 0' }}>
                    How to merge columns:
                </Typography>

                <TableContainer component={Paper} style={{ maxHeight: '400px', overflowY: 'auto' }}>
                    <Table>
                        <TableHead>
                            <TableRow>
                                <TableCell>{currentNetwork.name}</TableCell>
                                <TableCell>{availableNetworks[networksToBeMerged]?.name ?? 'Network to be Merged'}</TableCell>
                                <TableCell>Merged Network</TableCell>
                                <TableCell>Column Type</TableCell>
                            </TableRow>
                        </TableHead>
                        {view === 'node' ? (<TableBody>
                            <TableRow>
                                <TableCell>{matchingColOne ?? 'Matching Column One'}</TableCell>
                                <TableCell>{matchingColTwo ?? 'Matching Column Two'}</TableCell>
                                <TableCell>Matching.Attribute</TableCell>
                                <TableCell>{currentNetwork.nodeColumns.find(column => column.name === matchingColOne)?.type ?? 'unknown'}</TableCell>
                            </TableRow>
                            {
                                // Create a merged list of unique column names from both networks
                                [...new Set([
                                    ...currentNetwork.nodeColumns.map(column => column.name),
                                    ...(availableNetworks[networksToBeMerged]?.nodeColumns || []).map(column => column.name)
                                ])].map((columnName) => {
                                    const currentColumn = currentNetwork.nodeColumns.find(column => column.name === columnName);
                                    const secondColumn = availableNetworks[networksToBeMerged]?.nodeColumns.find(column => column.name === columnName);

                                    return (
                                        <TableRow key={columnName}>
                                            <TableCell>
                                                {currentColumn ? currentColumn.name : ''}
                                            </TableCell>
                                            <TableCell>
                                                {secondColumn ? secondColumn.name : ''}
                                            </TableCell>
                                            <TableCell>
                                                {/* If column exists in both networks and have the same type, list it once. 
                                                Otherwise, list column names from both networks. */}
                                                {currentColumn && secondColumn && currentColumn.type === secondColumn.type ? columnName : `${currentColumn ? currentColumn.name : ''} ${secondColumn ? secondColumn.name : ''}`}
                                            </TableCell>
                                            <TableCell>
                                                {/* Show column type if available, prioritize current network's column type */}
                                                {currentColumn ? currentColumn.type : secondColumn ? secondColumn.type : ''}
                                            </TableCell>
                                        </TableRow>
                                    );
                                })
                            }
                        </TableBody>) :
                            (<TableBody>
                                {
                                    // Create a merged list of unique column names from both networks
                                    [...new Set([
                                        ...currentNetwork.edgeColumns.map(column => column.name),
                                        ...(availableNetworks[networksToBeMerged]?.edgeColumns || []).map(column => column.name)
                                    ])].map((columnName) => {
                                        const currentColumn = currentNetwork.edgeColumns.find(column => column.name === columnName);
                                        const secondColumn = availableNetworks[networksToBeMerged]?.edgeColumns.find(column => column.name === columnName);

                                        return (
                                            <TableRow key={columnName}>
                                                <TableCell>
                                                    {currentColumn ? currentColumn.name : ''}
                                                </TableCell>
                                                <TableCell>
                                                    {secondColumn ? secondColumn.name : ''}
                                                </TableCell>
                                                <TableCell>
                                                    {/* If column exists in both networks and have the same type, list it once. 
                                                Otherwise, list column names from both networks. */}
                                                    {currentColumn && secondColumn && currentColumn.type === secondColumn.type ? columnName : `${currentColumn ? currentColumn.name : ''} ${secondColumn ? secondColumn.name : ''}`}
                                                </TableCell>
                                                <TableCell>
                                                    {/* Show column type if available, prioritize current network's column type */}
                                                    {currentColumn ? currentColumn.type : secondColumn ? secondColumn.type : ''}
                                                </TableCell>
                                            </TableRow>
                                        );
                                    })
                                }
                            </TableBody>)
                        }
                    </Table>
                </TableContainer>


                <FormControl fullWidth margin="normal">
                    <InputLabel id="networks-to-merge-label">Choose the Networks to be Merged</InputLabel>
                    <Select
                        labelId="networks-to-merge-label"
                        id="networks-to-merge-select"
                        multiple
                        value={networksTBMerged}
                        onChange={handleNetworksTBMerged}
                        input={<OutlinedInput id="select-multiple-chip" label="Choose the Networks to be Merged" />}
                        renderValue={(selected) => (
                            <div style={{ display: 'flex', flexWrap: 'wrap', gap: '10px' }}>
                                {selected.map((id) => (
                                    <Chip
                                        key={id}
                                        label={availableNetworks[id].name}
                                        onClick={(event) => event.stopPropagation()}
                                    />
                                ))}
                            </div>
                        )}
                    >
                        {Object.keys(availableNetworks).map((externalId) => (
                            <MenuItem key={externalId} value={externalId}>
                                {availableNetworks[externalId].name}
                            </MenuItem>
                        ))}
                    </Select>
                </FormControl>

